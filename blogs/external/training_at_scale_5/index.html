<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>layout: external_blog title: “Import your model and data classes here\nfrom src.model.lightning_module import AutoencoderModule as ModelClass\nfrom src.data.lightning_datamodule import DummyDataModule as DataModuleClass\n<code class="language-plaintext highlighter-rouge">\n\n# Default model and data classes to use if not overridden by command line arguments\nDEFAULT_MODEL_CLASS = ModelClass\nDEFAULT_DATA_CLASS = DataModuleClass\n\n\n### Required Arguments\n\n- `-c, --config`: Path to the YAML configuration file\n- `--model-class`: Import path to the model class (e.g., 'src.model.lightning_module.AutoencoderModule')\n- `--data-class`: Import path to the data module class (e.g., 'src.data.lightning_datamodule.DummyDataModule')\n\n### Optional Arguments\n\n- `--epochs`: Number of epochs to run (default: 2)\n- `--save-dir`: Directory to save results (default: results/benchmark/TIMESTAMP)\n- `--precision`: Training precision, choices are \"16-mixed\", \"16\", \"32\" (default: \"32\")\n- `--device`: Device to run on, choices are \"cuda\", \"cpu\" (default: auto-detect)\n\n## Output\n\nThe benchmark tool will create several files in the specified output directory:\n\n- `timing_summary.yaml`: A YAML file containing detailed timing statistics\n- `timing_results.csv`: A CSV file with raw timing data for each batch\n- `batch_time_breakdown.png`: A stacked bar chart showing time breakdown per batch\n- `total_batch_time.png`: A line plot of total batch time\n- `time_distribution_pie.png`: A pie chart of average time distribution\n- `benchmark_config.yaml`: A copy of the benchmark configuration\n\n## Tips for Optimization\n\n1. **Data Loading**:\n - If data loading takes &gt;30% of batch time, check the data pipeline and the dataloader again.\n\n2. **Forward/Backward Pass**:\n - Try mixed precision training with `--precision 16-mixed` for faster computation (discussed in [5. What Is Next](5.%20What%20Is%20Next.md))\n - Consider model architecture changes to reduce computation\n\n3. **Optimizer**:\n - Experiment with different optimizers and their settings\n\n## Analyzing Results\n\nThe benchmark results will help you identify bottlenecks in your training pipeline:\n\n- If **data loading** is the bottleneck, optimize data loading pipeline, increase workers, use caching\n- If **forward pass** is the bottleneck, consider model architecture changes or mixed precision\n- If **backward pass** is the bottleneck, try gradient accumulation or mixed precision\n- If **other ops** is the bottleneck, TODO: check with laurens andy\n\n\n## Profiling: Check Your Pipeline\n\n### What Is It?\n\nProfiling helps you understand where time and resources are spent in your training pipeline. It guides optimization by identifying bottlenecks. \nThe profiler also looks at data part of the pipeline, so it is a good idea to run it after the data part is done.\n\n### How Does It Work?\n\nLook at the provided script to profile your training loop:\n\n</code>bash\nprofiler.py\n```\n\nImport your <code class="language-plaintext highlighter-rouge">dataloader</code>and<code class="language-plaintext highlighter-rouge">model</code>modules, then run the script 3 times with the three profilers:\n\n- <strong>Simple Profiler</strong>\n- <strong>Advanced Profiler</strong>\n- <strong>PyTorch Profiler (Chrome Trace Viewer)</strong>\n\nit stores the output in the<code class="language-plaintext highlighter-rouge">output/profiler/{config_name}/profiler_logs</code> folder.\n\n\n### Interpreting Profiler Outputs – A Quick Guide\n\nUnderstanding what the profiler outputs mean is key to optimizing your training pipeline. \nHere’s what to look for in each profiler and how to make sense of the data.\n\n### 1.<code class="language-plaintext highlighter-rouge">fit-simple_profiler_output.txt</code> – Summary View (Simple Profiler)\n\n### What It Shows:\n- High-level summary of function calls\n- Average time per operation\n- Relative contribution of each function to total runtime\n\n### How to Read It:\n- Look at the top-consuming operations — these are usually bottlenecks.\n- Pay attention to data loading functions (<code class="language-plaintext highlighter-rouge">\*\_dataloader_next</code>, <code class="language-plaintext highlighter-rouge">**next**</code>) — these often take more time than expected.\n- Training loops like <code class="language-plaintext highlighter-rouge">run_training_epoch</code> will typically be a large portion; the key is to ensure they’re not dwarfed by overheads.\n\n### When to Take Action (example):\n- If data loading takes a large share of total time (e.g., &gt;40%), your pipeline is I/O-bound.\n- If your model training steps are taking less time than preprocessing, you’re likely under-utilizing the GPU.\n\n### 2.<code class="language-plaintext highlighter-rouge">fit-advanced_profiler_output.txt</code> – Line-Level View\n\n### What It Shows:\n- Function-level granularity (per-call stats)\n- Total calls, total time, average time per call\n- Stack trace to locate the exact code path\n\n### How to Read It:\n- Sort by total time and identify high-call-count, low-time ops — these may be optimized or batched.\n- Use stack traces to pinpoint performance sinks inside your own code or framework code.\n- Investigate setup or utility functions being called excessively (e.g., synthetic data generation, logging, checkpointing).\n\n### When to Take Action (example):\n- If any function is causing a lot of time, (where you expect it to be fast) check if it is necessary.\n\n### 3.<code class="language-plaintext highlighter-rouge">pt.trace.json</code>– Chrome Trace Viewer (PyTorch Profiler)\n\n### What It Shows:\n- Frame-by-frame execution timeline\n- Operator-level breakdown (CPU and GPU)\n- Optional memory usage tracking\n\n### How to Read It:\n1. Open Chrome and go to<code class="language-plaintext highlighter-rouge">chrome://tracing</code>.\n2. Drop in the <code class="language-plaintext highlighter-rouge">.json</code>file.\n3. Hover over timeline blocks to see operator names, start/end times, and device usage.\n\n### What to Look For:\n- Long horizontal bars → slow operations (usually backward passes, large convolutions)\n- Gaps between ops → potential I/O waits or CPU/GPU syncs\n- Overlapping CPU/GPU ops → good utilization\n- Memory heatmaps (if enabled) → identify peaks or leaks\n\n### When to Take Action (example):\n- If any function is causing a lot of time, (where you expect it to be fast) check if it is necessary.\n- If idle gaps exist, investigate DataLoader efficiency \n\n## Next Steps\n\nCongratulations on optimizing your entire training pipeline! Explore what’s next:\n\n<a href="5.%20What%20Is%20Next.md">5. What Is Next</a>\n\n\nTODO read and review\n- <a href="https://lightning.ai/docs/pytorch/stable/advanced/compile.html" rel="external nofollow noopener" target="_blank">PyTorch Lightning:<code class="language-plaintext highlighter-rouge">compile</code> for speed</a> \ + sharding and stuff, not sure if needed RN\n- <a href="https://lightning.ai/docs/pytorch/stable/advanced/speed.html" rel="external nofollow noopener" target="_blank">PyTorch Lightning: General speed-up tips</a>\n” description: “- <a href="https://lightning.ai/docs/pytorch/stable/advanced/speed.html" rel="external nofollow noopener" target="_blank">PyTorch Lightning: General speed-up tips</a>” date: ‘2025-05-05’ collection: external_blogs collection_id: training_at_scale chapter_number: 5 source_repo: https://github.com/CoenvdE/Training-at-larger-scale-blog original_file: “/4. Optimizing the pipeline: Model.md”</p> <hr> <h2 id="4-optimizing-the-pipeline-model">4. Optimizing the pipeline: Model</h2> <p>After optimizing the data pipeline, the next step is profiling the model pipeline to catch bottlenecks like slow ops or CPU–GPU data transfers. This is an optional step that, if the code is implemented correctly, will probably not have a big impact on the training time. if you don’t want to do it, you can skip this section and look at <a href="5.%20What%20Is%20Next.md">What Is Next</a>. Note that I give a few nice tools to help you analyse the model pipeline performance. I do suggest you to run the benchmark (and a pytorch profiler) and let ChatGPT or another good LLM analyse the results for you and help you figure out if you need to change something. This part is mainly about getting the time it takes for a batch to pass through your model pipeline down.</p> <p>The time it takes for a batch to pass through your model depends on several factors:</p> <ul> <li> <strong>Batch size</strong>: Larger batch sizes generally increase the duration of a single training step because more data is processed simultaneously. Operations like a dot product scale linearly with the batch size, so the duration of a single training step increases with the batch size. However, the relationship isn’t always linear - GPUs can achieve higher utilization with larger batches, potentially making the per-sample processing time lower.</li> <li> <p><strong>Model complexity</strong>: More complex models (deeper, wider networks) take longer to process each batch.</p> </li> <li> <strong>Hardware</strong>: The specs of your GPU/TPU significantly impact processing time.</li> </ul> <p>TODO (rewrite when discussed with laurens and andy): check if this is correct. In my experiments, a single training step took around 0.4 seconds for moderate-sized models with a batch size of 32. This can vary widely - from milliseconds for small models to several seconds for large transformer architectures. I have seen 0.1 seconds as well with other models.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4. Optimizing the pipeline: Model/
├── profiler.py
├── timing_benchmark.py
├── config/
│   ├── cli_config.yaml
├── src/
│   ├── data/
│   │   ├── lightning_datamodule.py
│   │   └── pytorch_dataset.py
│   └── model/
│       ├── lightning_module.py
│       ├── pytorch_decoder.py
│       ├── pytorch_encoder.py
│       └── pytorch_model.py
├── tests/
│   └── test_lightning_parameters.py
└── output/
</code></pre></div></div> <h3 id="easy-timing-benchmark">easy timing benchmark</h3> <p>This is a tool I made to benchmark the any pipeline. It is designed to work with any PyTorch Lightning module and data module, so you can use it to benchmark your model pipeline. It measures detailed timing information for each step of the training process:</p> <ul> <li>Data loading time</li> <li>Forward pass time</li> <li>Backward pass time</li> <li>Other ops: everything that happens after the backward pass but before the end of the batch. This primarily includes: <ul> <li>The optimizer step (applying gradients to update model weights)</li> <li>Scaler updates (when using mixed precision)</li> <li>Any additional overhead between batches</li> </ul> </li> </ul> <p>I find the timing summary at the end of the script to be very useful. It gives you a good overview of the time spent in each step of the pipeline.</p> <h2 id="usage">Usage</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python timing_benchmark.py <span class="nt">-c</span> config/config.yaml <span class="nt">--epochs</span> 1 <span class="nt">--save-dir</span> results/benchmark/my_model
</code></pre></div></div> <p>Replace the model and data classes with your own.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Import your model and data classes here
</span><span class="kn">from</span> <span class="n">src.model.lightning_module</span> <span class="kn">import</span> <span class="n">AutoencoderModule</span> <span class="k">as</span> <span class="n">ModelClass</span>
<span class="kn">from</span> <span class="n">src.data.lightning_datamodule</span> <span class="kn">import</span> <span class="n">DummyDataModule</span> <span class="k">as</span> <span class="n">DataModuleClass</span>
</code></pre></div></div> <h1 id="default-model-and-data-classes-to-use-if-not-overridden-by-command-line-arguments">Default model and data classes to use if not overridden by command line arguments</h1> <p>DEFAULT_MODEL_CLASS = ModelClass DEFAULT_DATA_CLASS = DataModuleClass</p> <h3 id="required-arguments">Required Arguments</h3> <ul> <li> <code class="language-plaintext highlighter-rouge">-c, --config</code>: Path to the YAML configuration file</li> <li> <code class="language-plaintext highlighter-rouge">--model-class</code>: Import path to the model class (e.g., ‘src.model.lightning_module.AutoencoderModule’)</li> <li> <code class="language-plaintext highlighter-rouge">--data-class</code>: Import path to the data module class (e.g., ‘src.data.lightning_datamodule.DummyDataModule’)</li> </ul> <h3 id="optional-arguments">Optional Arguments</h3> <ul> <li> <code class="language-plaintext highlighter-rouge">--epochs</code>: Number of epochs to run (default: 2)</li> <li> <code class="language-plaintext highlighter-rouge">--save-dir</code>: Directory to save results (default: results/benchmark/TIMESTAMP)</li> <li> <code class="language-plaintext highlighter-rouge">--precision</code>: Training precision, choices are “16-mixed”, “16”, “32” (default: “32”)</li> <li> <code class="language-plaintext highlighter-rouge">--device</code>: Device to run on, choices are “cuda”, “cpu” (default: auto-detect)</li> </ul> <h2 id="output">Output</h2> <p>The benchmark tool will create several files in the specified output directory:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">timing_summary.yaml</code>: A YAML file containing detailed timing statistics</li> <li> <code class="language-plaintext highlighter-rouge">timing_results.csv</code>: A CSV file with raw timing data for each batch</li> <li> <code class="language-plaintext highlighter-rouge">batch_time_breakdown.png</code>: A stacked bar chart showing time breakdown per batch</li> <li> <code class="language-plaintext highlighter-rouge">total_batch_time.png</code>: A line plot of total batch time</li> <li> <code class="language-plaintext highlighter-rouge">time_distribution_pie.png</code>: A pie chart of average time distribution</li> <li> <code class="language-plaintext highlighter-rouge">benchmark_config.yaml</code>: A copy of the benchmark configuration</li> </ul> <h2 id="tips-for-optimization">Tips for Optimization</h2> <ol> <li> <p><strong>Data Loading</strong>:</p> <ul> <li>If data loading takes &gt;30% of batch time, check the data pipeline and the dataloader again.</li> </ul> </li> <li> <p><strong>Forward/Backward Pass</strong>:</p> <ul> <li>Try mixed precision training with <code class="language-plaintext highlighter-rouge">--precision 16-mixed</code> for faster computation (discussed in <a href="5.%20What%20Is%20Next.md">5. What Is Next</a>)</li> <li>Consider model architecture changes to reduce computation</li> </ul> </li> <li> <p><strong>Optimizer</strong>:</p> <ul> <li>Experiment with different optimizers and their settings</li> </ul> </li> </ol> <h2 id="analyzing-results">Analyzing Results</h2> <p>The benchmark results will help you identify bottlenecks in your training pipeline:</p> <ul> <li>If <strong>data loading</strong> is the bottleneck, optimize data loading pipeline, increase workers, use caching</li> <li>If <strong>forward pass</strong> is the bottleneck, consider model architecture changes or mixed precision</li> <li>If <strong>backward pass</strong> is the bottleneck, try gradient accumulation or mixed precision</li> <li>If <strong>other ops</strong> is the bottleneck, TODO: check with laurens andy</li> </ul> <h2 id="profiling-check-your-pipeline">Profiling: Check Your Pipeline</h2> <h3 id="what-is-it">What Is It?</h3> <p>Profiling helps you understand where time and resources are spent in your training pipeline. It guides optimization by identifying bottlenecks. The profiler also looks at data part of the pipeline, so it is a good idea to run it after the data part is done.</p> <h3 id="how-does-it-work">How Does It Work?</h3> <p>Look at the provided script to profile your training loop:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>profiler.py
</code></pre></div></div> <p>Import your <code class="language-plaintext highlighter-rouge">dataloader</code> and <code class="language-plaintext highlighter-rouge">model</code> modules, then run the script 3 times with the three profilers:</p> <ul> <li><strong>Simple Profiler</strong></li> <li><strong>Advanced Profiler</strong></li> <li><strong>PyTorch Profiler (Chrome Trace Viewer)</strong></li> </ul> <p>it stores the output in the <code class="language-plaintext highlighter-rouge">output/profiler/{config_name}/profiler_logs</code> folder.</p> <h3 id="interpreting-profiler-outputs--a-quick-guide">Interpreting Profiler Outputs – A Quick Guide</h3> <p>Understanding what the profiler outputs mean is key to optimizing your training pipeline. Here’s what to look for in each profiler and how to make sense of the data.</p> <h3 id="1-fit-simple_profiler_outputtxt--summary-view-simple-profiler">1. <code class="language-plaintext highlighter-rouge">fit-simple_profiler_output.txt</code> – Summary View (Simple Profiler)</h3> <h3 id="what-it-shows">What It Shows:</h3> <ul> <li>High-level summary of function calls</li> <li>Average time per operation</li> <li>Relative contribution of each function to total runtime</li> </ul> <h3 id="how-to-read-it">How to Read It:</h3> <ul> <li>Look at the top-consuming operations — these are usually bottlenecks.</li> <li>Pay attention to data loading functions (<code class="language-plaintext highlighter-rouge">*_dataloader_next</code>, <code class="language-plaintext highlighter-rouge">__next__</code>) — these often take more time than expected.</li> <li>Training loops like <code class="language-plaintext highlighter-rouge">run_training_epoch</code> will typically be a large portion; the key is to ensure they’re not dwarfed by overheads.</li> </ul> <h3 id="when-to-take-action-example">When to Take Action (example):</h3> <ul> <li>If data loading takes a large share of total time (e.g., &gt;40%), your pipeline is I/O-bound.</li> <li>If your model training steps are taking less time than preprocessing, you’re likely under-utilizing the GPU.</li> </ul> <h3 id="2-fit-advanced_profiler_outputtxt--line-level-view">2. <code class="language-plaintext highlighter-rouge">fit-advanced_profiler_output.txt</code> – Line-Level View</h3> <h3 id="what-it-shows-1">What It Shows:</h3> <ul> <li>Function-level granularity (per-call stats)</li> <li>Total calls, total time, average time per call</li> <li>Stack trace to locate the exact code path</li> </ul> <h3 id="how-to-read-it-1">How to Read It:</h3> <ul> <li>Sort by total time and identify high-call-count, low-time ops — these may be optimized or batched.</li> <li>Use stack traces to pinpoint performance sinks inside your own code or framework code.</li> <li>Investigate setup or utility functions being called excessively (e.g., synthetic data generation, logging, checkpointing).</li> </ul> <h3 id="when-to-take-action-example-1">When to Take Action (example):</h3> <ul> <li>If any function is causing a lot of time, (where you expect it to be fast) check if it is necessary.</li> </ul> <h3 id="3-pttracejson--chrome-trace-viewer-pytorch-profiler">3. <code class="language-plaintext highlighter-rouge">pt.trace.json</code> – Chrome Trace Viewer (PyTorch Profiler)</h3> <h3 id="what-it-shows-2">What It Shows:</h3> <ul> <li>Frame-by-frame execution timeline</li> <li>Operator-level breakdown (CPU and GPU)</li> <li>Optional memory usage tracking</li> </ul> <h3 id="how-to-read-it-2">How to Read It:</h3> <ol> <li>Open Chrome and go to <code class="language-plaintext highlighter-rouge">chrome://tracing</code>.</li> <li>Drop in the <code class="language-plaintext highlighter-rouge">.json</code> file.</li> <li>Hover over timeline blocks to see operator names, start/end times, and device usage.</li> </ol> <h3 id="what-to-look-for">What to Look For:</h3> <ul> <li>Long horizontal bars → slow operations (usually backward passes, large convolutions)</li> <li>Gaps between ops → potential I/O waits or CPU/GPU syncs</li> <li>Overlapping CPU/GPU ops → good utilization</li> <li>Memory heatmaps (if enabled) → identify peaks or leaks</li> </ul> <h3 id="when-to-take-action-example-2">When to Take Action (example):</h3> <ul> <li>If any function is causing a lot of time, (where you expect it to be fast) check if it is necessary.</li> <li>If idle gaps exist, investigate DataLoader efficiency</li> </ul> <h2 id="next-steps">Next Steps</h2> <p>Congratulations on optimizing your entire training pipeline! Explore what’s next:</p> <p><a href="5.%20What%20Is%20Next.md">5. What Is Next</a></p> <p>TODO read and review</p> <ul> <li> <a href="https://lightning.ai/docs/pytorch/stable/advanced/compile.html" rel="external nofollow noopener" target="_blank">PyTorch Lightning: <code class="language-plaintext highlighter-rouge">compile</code> for speed</a> + sharding and stuff, not sure if needed RN</li> <li><a href="https://lightning.ai/docs/pytorch/stable/advanced/speed.html" rel="external nofollow noopener" target="_blank">PyTorch Lightning: General speed-up tips</a></li> </ul> </body></html>