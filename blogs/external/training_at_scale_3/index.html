<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>layout: external_blog title: 2. Bigger Data In The Cloud description: Part of the Training at Scale series date: ‘2025-05-05’ collection: external_blogs collection_id: training_at_scale chapter_number: 3 source_repo: https://github.com/CoenvdE/Training-at-larger-scale-blog original_file: “/2. Bigger data in the cloud.md”</p> <hr> <h2 id="2-bigger-data-in-the-cloud">2. Bigger Data In The Cloud</h2> <p>In this part, I will provide a general overview of what streaming is and how to work with data in the cloud, I will also provide a usecase specific example for loading and working with geospatial data (xarray) to show an example of with bigger datasets.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2. Bigger data in the cloud/
├── data/
│   ├── usecase_cloud_dataset.py
│   ├── utils.py
│   ├── usecase_API_access.py
│   ├── usecase_cloud_access.py
│   ├── example_cloud_access.py
│   └── __pycache__/
├── output/
│   ├── copernicus_data/
│   └── test/
└── __pycache__/
</code></pre></div></div> <h3 id="quick-recap">Quick Recap:</h3> <p><strong>torch.utils.data.Dataset</strong>: A PyTorch Dataset is a class that tells PyTorch how to get one data sample. It acts as a blueprint for reading a sample from storage (local disk or xloud storage) into active memory (RAM). It has two main functions:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">__len__</code>: how many samples there are</li> <li> <code class="language-plaintext highlighter-rouge">__getitem__</code>: how to get one sample (e.g., load an image, label) Note that this can be from local storage or from the cloud.</li> </ul> <p>The dataset doesn’t load anything. It’s just a blueprint.</p> <p>Cloud data is typically stored on object storage servers like:</p> <ul> <li>Amazon S3</li> <li>Google Cloud Storage (GCS)</li> <li>Azure Blob Storage</li> </ul> <p>NOTE: more reading: <a href="https://pytorch.org/tutorials/beginner/basics/data_tutorial.html" rel="external nofollow noopener" target="_blank">PyTorch Dataset Tutorial</a></p> <h2 id="the-problem-datasets-that-are-to-big-for-memory-or-local-disk">The Problem: datasets that are to big for memory or local disk</h2> <p>Most data that you will use lives in “the cloud”: servers somewhere on the planet, with all the data you will ever need. You can access data on the internet and download it to locally (like CIFAR-10, as implemented by pytorch). So what do you do when you have so much data that it does not fit on your local machine?</p> <p>One solution is to buy hard drive and store the data on there. This itself is quite expensive, but could be beneficial if you have the hardware (GPU) yourself. In this case, you can just keep the whole pipeline local, but this is only beneficial you to have (multiple GPU’s), which is super expensive.</p> <p>TODO (With Laurens): add a part of mounting a virtual SSD (or something like that) to the cloud compute instance. and working with that. (pros and cons)</p> <p>Since I don’t have a lot of GPUs (or money), I chose another option: streaming/lazy-loading. Streaming or lazy-loading datasets means loading data only when needed, rather than reading everything into memory upfront. This approach is useful for large datasets that don’t fit in memory or are stored in remote data sources. Instead, you load samples (or chunks of data) on-the-fly as needed, directly from cloud storage servers. This avoids filling up local storage or memory while still giving you access to massive datasets that would otherwise be impossible to work with on limited hardware.</p> <p>Some examples where this happens:</p> <ul> <li>Hugging Face Datasets (streaming=True)</li> <li>WebDataset format (tar files accessed remotely or locally)</li> <li>Some torch.utils.data.Dataset implementations with lazy loading</li> <li>Some API’s provide this functionality</li> </ul> <h3 id="getting-access-to-the-data">Getting access to the data</h3> <p>When you want to stream/lazy-load/get data from cloud storage, you need access to the place it is stored (commonly called buckets). This can sometimes be implemented already by API’s (e.g. Huggingface, or my usecase: Copernicus, see <code class="language-plaintext highlighter-rouge">usecase_API_access.py</code>).</p> <p>In my case, I needed to get access to the cloud storage directly without the API. This direct access gave me more flexibility and control over how I loaded the data. I implemented this using the <code class="language-plaintext highlighter-rouge">fsspec</code> library, which provides a unified interface for working with different file systems and storage backends. This approach was particularly valuable because:</p> <ol> <li>It allowed me to work with multiple storage providers using the same code</li> <li>It enabled parallel data access, significantly improving loading speeds</li> <li>It gave me fine-grained control over chunking and caching strategies</li> <li>It integrated well with my existing PyTorch data pipeline</li> </ol> <p>I’ve created both a general example (<code class="language-plaintext highlighter-rouge">example_cloud_access.py</code>) and a use-case specific (<code class="language-plaintext highlighter-rouge">usecase_cloud_access.py</code>) implementation showing how to access data in the cloud efficiently</p> <p>NOTE (With Laurens): COPERNICUS DIDNT WANT EVERYONE TO KNOW, IS THIS OKAY?</p> <h3 id="streaminglazy-loading">Streaming/Lazy Loading</h3> <p>Now that we have access to the data, we can stream it into memory! For my geospatial data use case, I utilized libraries like Dask and Xarray that provide optimizable, efficient lazy loading capabilities. Dask helps create a computational graph for loading data chunks from storage only when needed, while managing parallel workers to speed up the process. I’ll cover optimization strategies for (streaming) data pipelines in <a href="3.%20Optimizing%20the%20pipeline%3A%20Data.md">Chapter 3: Optimizing the Pipeline: Data</a>. To be able to work with this (lazy-loaded) data from the cloud in your training pipeline, we need to wrap everything into a PyTorch dataset. I’ve implemented an example in <code class="language-plaintext highlighter-rouge">usecase_cloud_dataset.py</code> that demonstrates how to create a custom Dataset class that handles cloud data access, lazy loading and converting it to a usable dataset. Note that this is still a simplified version. When working with Xarray, xbatcher is the most efficient way to use batch generation, but this is out of the scope of this guide. Feel free to ask any questions about this.</p> <h3 id="quick-recap-1">Quick Recap:</h3> <p><strong>torch.utils.data.Dataloader</strong>: A PyTorch DataLoader defines how to load (many) samples (efficiently) (batching, multiprocessing, shuffling, etc.). Basically the DataLoader keeps asking the Dataset (blueprint) for samples, and handles the rest. It:</p> <ul> <li>Wraps a Dataset</li> <li>Loads batches of data (samples) (in parallel using multiple workers)</li> <li>Handles shuffling, batching, prefetching, etc.</li> <li>Dataloader has been used to parallelize the data loading as this boosts up the speed and saves memory.</li> </ul> <p>The Dataloader calls the <strong>getitem</strong>() from the Dataset to get the needed samples. The Dataset (blueprint) defines “what” a sample is and how to get it, the DataLoader defines how to load them efficiently.</p> <h3 id="dataloader-parameters-for-efficient-data-loading-from-the-cloud">DataLoader Parameters for Efficient Data Loading (from the cloud)</h3> <p><strong>Number of Workers (<code class="language-plaintext highlighter-rouge">num_workers</code>)</strong>:</p> <ul> <li>Specifies how many subprocesses should be used to load data. Each of these subprocesses retrieves a batch of data from your dataset and sends it to the main training process. This is not necessarily equal to the number of cores/threads the dataloader uses. Each worker operates independently, loading data in parallel. The loaded data is then sent to the main process(es) for use in training, creating an overlap between training and data loading that reduces idle GPU time. Under the hood, the dataset object is replicated in each worker.</li> <li> <code class="language-plaintext highlighter-rouge">num_workers=0</code>: Data is loaded in the main process. No parallelism.</li> <li> <code class="language-plaintext highlighter-rouge">num_workers=N</code>: Spawns N worker processes to load data in parallel. <ul> <li>Note: This is <strong>not the number of CPU cores</strong>, but the number of subprocesses that utilize CPU resources.</li> </ul> </li> <li>each worker might maintain its own HTTP connection or file handle. This can increase throughput (multiple parallel reads) but also load (e.g., more network connections). Ensure your data source can handle concurrent access.</li> </ul> <p>I will show how to optimize this in the next chapter <a href="3.%20Optimizing%20the%20pipeline%3A%20Data.md">Optimizing the Pipeline: Data</a></p> <p><strong>Persistent Workers (<code class="language-plaintext highlighter-rouge">persistent_workers</code>)</strong>:</p> <ul> <li>If <code class="language-plaintext highlighter-rouge">True</code>, keeps worker processes alive across epochs and thus reduces worker startup overhead.</li> <li>Especially useful when using slower file systems or large datasets as opening/closing files is time expensive.</li> <li>While persistent workers reduce startup overhead, they can lead to increased memory usage over time as workers may accumulate cached data or experience memory leaks. If you notice growing memory consumption during training. In this case you should reduce the number of workers.</li> </ul> <p><strong>Pin Memory (<code class="language-plaintext highlighter-rouge">pin_memory</code>)</strong>:</p> <ul> <li>If <code class="language-plaintext highlighter-rouge">True</code>, enables automatic allocation of fetched tensors into page-locked (pinned) memory. This can significantly speed up host (CPU) to device (GPU) memory transfer. <ul> <li>Normal memory -&gt; GPU: Requires copy to temporary pageable buffer first</li> <li>Pinned memory -&gt; GPU: Direct transfer without intermediate copies</li> </ul> </li> <li>Requires that your dataset’s <code class="language-plaintext highlighter-rouge">__getitem__</code> returns <code class="language-plaintext highlighter-rouge">torch.Tensor</code> objects.</li> </ul> <p><strong>Prefetch Factor (<code class="language-plaintext highlighter-rouge">prefetch_factor</code>)</strong>:</p> <ul> <li>Number of batches loaded in advance by each worker.</li> <li>Total prefetched batches = <code class="language-plaintext highlighter-rouge">num_workers * prefetch_factor</code>. This needs to taken into account for memory consumption</li> <li>Higher values increase memory usage, but can improve throughput by reducing I/O bottlenecks.</li> <li>If using streaming datasets (WebDataset tar files, tf.data pipelines, etc.), ensure you take advantage of their features like prefetching and parallel reads</li> </ul> <p>I will show how to optimize this in the next chapter <a href="3.%20Optimizing%20the%20pipeline%3A%20Data.md">Optimizing the Pipeline: Data</a></p> <p><strong>Multiprocessing Context</strong>: Controls how worker processes are created in the DataLoader (usable with multiple workers):</p> <ul> <li>Use <code class="language-plaintext highlighter-rouge">multiprocessing_context='forkserver'</code> (or <code class="language-plaintext highlighter-rouge">'spawn'</code>) for compatibility with CUDA and complex I/O or filesystem interactions.</li> <li> <code class="language-plaintext highlighter-rouge">'spawn'</code> is the most compatible and is default on Windows and MacOS. Creates entirely new Python processes from scratch, with clean memory space. Safest but slowest method since it needs to re-import modules in each worker.</li> <li> <code class="language-plaintext highlighter-rouge">'forkserver'</code> can also be safer than <code class="language-plaintext highlighter-rouge">'fork'</code> (default on Linux) when using CUDA. Creates a server process that handles forking child processes on demand. Offers a good balance between safety and performance.</li> <li> <code class="language-plaintext highlighter-rouge">'fork'</code> is fast but can lead to subtle bugs with CUDA or file handles. Default on Linux. Creates workers by duplicating the entire parent process memory, including all open resources. Fast but dangerous with complex resources like CUDA contexts or file handles.</li> </ul> <p>When this is not set correctly, you can run into gridlock. This is when worker processes become deadlocked or severely bottlenecked, preventing efficient data flow. Common scenarios include:</p> <ul> <li>CUDA errors when using <code class="language-plaintext highlighter-rouge">'fork'</code> with GPU operations</li> <li>Corrupted file handles when using <code class="language-plaintext highlighter-rouge">'fork'</code> with complex I/O</li> <li>Memory leaks from improper resource sharing</li> <li>Deadlocks from competing access to shared resources</li> </ul> <p><strong>Worker Initialization (<code class="language-plaintext highlighter-rouge">worker_init_fn</code>)</strong>:</p> <ul> <li>Optional function to initialize each worker after it’s spawned.</li> <li>For cloud use: configure filesystem-specific settings and avoid duplication randomness across workers. An example is shown in <code class="language-plaintext highlighter-rouge">utils.py</code> </li> <li>NOTE: Initialization functions are called once per worker process, not once per batch.</li> </ul> <p><strong>Additional Resources:</strong></p> <ul> <li> <a href="https://pytorch.org/docs/stable/data.html" rel="external nofollow noopener" target="_blank">PyTorch DataLoader Documentation</a> - Complete reference for DataLoader parameters and best practices</li> <li> <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="external nofollow noopener" target="_blank">Python Multiprocessing Start Methods</a> - Details on fork, spawn, and forkserver methods and their implications</li> </ul> <p>Now we have a clean architecture setup that is validated and set up for multi-GPU training. We’ve learned how to access and stream data from the cloud, and configured our DataLoader with the appropriate parameters for efficient data loading. With these foundations in place, it’s time to optimize the components of our pipeline for better performance. Let’s start by focusing <a href="3.%20Optimizing%20the%20pipeline%3A%20Data.md">optimizing the data part of the pipeline</a></p> </body></html>